## [题目介绍](https://leetcode-cn.com/problems/climbing-stairs/ "原题链接")

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

## 题目解答

### 寻找子问题

原问题可以等价转换为**有多少种方法可以从第 1 个台阶爬到第 N 个台阶**，这个问题可以拆成如下 N 个子问题

- **子问题 1**: 多少种方法可以从第 1 个台阶爬到第 1 个台阶
- **子问题 2**: 多少种方法可以从第 1 个台阶爬到第 2 个台阶
- ... ...
- **子问题 N-1**: 多少种方法可以从第 1 个台阶爬到第 N-1 个台阶

很容易发现子问题为**有多少种方法可以从第 1 个台阶爬到第 N-1 个台阶**

### 寻找状态转移方程

从题意中可知状态转移条件为**每次你可以爬 1 个或 2 个台阶，并且花费相应体力值后到达下一个台阶**。也就是你可以从第 1 个台阶爬 2 格或从第 2 个台阶爬 1 格来到达第 3 个台阶。其中**状态转移条件**指明了在一个动态规划中如何从一个或多个状态转移到另一个状态。

在这道题中，是由两个状态来转移到另一个状态的，如下图所示，每一个圆形表示一个状态，每一个状态 N 表示一个子问题的答案。如果你计算出了某一个状态，也就表示你解决了某一个子问题。

![](https://img-blog.csdnimg.cn/0b5dfda4011f4246b01dd79b54e237fa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)
由于状态转移方程需要依赖前面的状态来计算，所以肯定会有一个或多个初始状态，从这些初始状态来一步一步计算其他状态。这些初始状态一般是一个初始值，在本题中**子问题 1**和**子问题 2**就表示初始状态。
在编码的时候，我们一般用一个 dp 数组来存储状态，到这里就可以得出如下状态转换方程

> dp[N] = dp[N-1] + dp[N-2]
> 其中 dp[1] = 1, dp[2] = 2

### 方法一：动态规划

#### 代码实现

```java
class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n ; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}
```

#### 复杂度分析

- *时间复杂度*: O(N)
- *空间复杂度*: O(N)

### 方法二：动态规划优化

在方法一中，dp[N] 的状态永远依赖于 dp[N-1] 和 dp[N-2]，我们可以使用滚动数组的思想来把 dp 数组优化掉。滚动数组思想表示在一个数组中(不限维度)，某一个下标为 N 的元素总是依赖于这个数组前面的某些元素，当求出这个下标为 N 的元素后，前面的某些元素就可以丢弃不要了，这时就可以优化数组空间，减少内存的使用。

```java
class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[2];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 3; i <= n ; i++) {
            int t = dp[1];
            dp[1] = dp[1] + dp[0];
            dp[0] = t;
        }
        return dp[1];
    }
}
```

#### 复杂度分析

- *时间复杂度*: O(N)
- *空间复杂度*: O(1)

## 其他

> **图解大厂面试高频算法题**专题文章主旨是: 根据*二八法则*的原理，以付出 20%的时间成本，获得 80%的刷题的收益，让那些想进互联网大厂或心仪公司的人少走些弯路。
>
> 本专题还在持续更新 ing~ 所有文章、图解和代码全部是金刀亲手完成。内容全部放在了[github](https://github.com/glodknife "github")和[gitee](https://gitee.com/goldknife6 "gitee")方便小伙伴们阅读和调试，另外还有更多小惊喜等你发现~
>
> 如果你喜欢本篇文章，PLZ 一键三连（关注、点赞、在看）。
