> PS: 这道题目估计是很多刷leetcode小伙伴们做的第一次，别以为这个题很简单而且是esay的就不重视它。金刀之前在大厂面试中真的遇到过这个问题，我都惊呆了竟然出这个题，说来惭愧，我竟然没写对！焯！所以大家还是要多多练习，掌握好基本功才能拿下好offer。

## [题目介绍](https://leetcode-cn.com/problems/reverse-linked-list/ "原题链接")
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。

### 示例1
![在这里插入图片描述](https://img-blog.csdnimg.cn/7c73f6efff234fddb70c1ba09b116fa7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

> *输入*：head = [1,2,3,4,5]
>
> *输出*：[5,4,3,2,1]

## 题目解答
### 方法一：迭代法

#### 思路和算法
基本思路大家应该很容易想出来，每遍历一个节点的时候，把当前节点的next指针指向前一个节点，在指向前一个节点之前需要先临时存储当前节点的next节点。

#### 图解
![在这里插入图片描述](https://img-blog.csdnimg.cn/825a6c2542244c2ab16c26814429e10e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)
#### 代码实现

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode t = head.next;
            head.next = prev;
            prev = head;
            head = t;
        }
        return prev;
    }
}
```
#### 复杂度分析
- *时间复杂度*：O(n)，其中 n 是链表的长度。需要遍历链表一次。
- *空间复杂度*：O(1)。

### 方法二：递归法
#### 思路和算法
首先我们改如何理解递归呢？我们假设reverseList函数可以把一个链表进行反转。

![](https://img-blog.csdnimg.cn/2af73c1e88214140a47ce73a9a64dddc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

红色框表示由reverseList递归返回的链表，其中蓝色节点为头节点，也就是newHead

![](https://img-blog.csdnimg.cn/472e6becaa83411688e4aed83dfa415e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

拿到了由reverseList返回的链表之后，我们需要把head.next节点指向head节点。因为当前head节点属于链表的最后一个节点，需要把head节点指向null，这样就完成了本次递归。

![](https://img-blog.csdnimg.cn/7901ad7d322a485f8b82723162c0783b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

另外需要注意一下递归的终止条件，如果head == null 或者 head.next == null 递归就终止了。
#### 代码实现

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```
#### 复杂度分析
- *时间复杂度*：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。
- *空间复杂度*：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。

## 其他

> **图解大厂面试高频算法题**专题文章主旨是: 根据*二八法则*的原理，以付出 20%的时间成本，获得 80%的刷题的收益，让那些想进互联网大厂或心仪公司的人少走些弯路。
>
> 本专题还在持续更新 ing~ 所有文章、图解和代码全部是金刀亲手完成。内容全部放在了[github](https://github.com/glodknife "github")和[gitee](https://gitee.com/goldknife6 "gitee")方便小伙伴们阅读和调试，另外还有更多小惊喜等你发现~
>
> 如果你喜欢本篇文章，PLZ 一键三连（关注、点赞、在看）。
