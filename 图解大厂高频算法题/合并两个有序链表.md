> PS: 这道题的解法是很多中等和困难难度题的基础，希望大家能熟练掌握。

## [题目介绍](https://leetcode-cn.com/problems/merge-two-sorted-lists/ "原题链接")

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

### 示例 1

![](https://img-blog.csdnimg.cn/d15e31c300d14820bf9aea0703ea4788.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

> _输入_：l1 = [1,2,4], l2 = [1,3,4]
>
> _输出_：[1,1,2,3,4,4]

## 题目解答

### 方法一：迭代

#### 思路和算法

迭代的思路显而易见，我们可以持续判断这两个链表头结点 l1 和 l2 是否为 null，如果都不为 null 时，去比较 l1 和 l2 头节点的值，把较小值的头节点拼接到新的链表里去。

**初始状态**
![](https://img-blog.csdnimg.cn/e885c289641a45d0b8a70e1cdeba04ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

**第一次迭代**
![](https://img-blog.csdnimg.cn/166223492f5c4b069e2036462ce2c647.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

**第二次迭代**
![](https://img-blog.csdnimg.cn/a62e2678e7d446709604577888847d6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

**第三次迭代**
![](https://img-blog.csdnimg.cn/2f50aa2672d443ae965751753d0b74f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

**第四次迭代**
![](https://img-blog.csdnimg.cn/d48dce066c4143a4bf7330961e5a37e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55-l5pil6Lev6YeR5YiA,size_20,color_FFFFFF,t_70,g_se,x_16)

**第五次迭代**

这时终止循环，l2 链表只剩下一个节点。
![](https://img-blog.csdnimg.cn/dca41ab1edec4e6ea6fbcb4c237098c5.png)

**拼接剩余链表**

把 l2 直接拼接到新链表中。
![在这里插入图片描述](https://img-blog.csdnimg.cn/92bc1217410f445fb7bb72456b1d8d46.png)

#### 代码实现

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dump = new ListNode();
        ListNode head = dump;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                head.next = l1;
                l1 = l1.next;
            } else {
                head.next = l2;
                l2 = l2.next;
            }
            head = head.next;
        }
        if (l1 != null) {
            head.next = l1;
        }
        if (l2 != null) {
            head.next = l2;
        }
        return dump.next;
    }
}
```

#### 复杂度分析

- _时间复杂度_:O(n+m)
- _空间复杂度_:O(1)


## 其他

> **图解大厂面试高频算法题**专题文章主旨是: 根据*二八法则*的原理，以付出 20%的时间成本，获得 80%的刷题的收益，让那些想进互联网大厂或心仪公司的人少走些弯路。
>
> 本专题还在持续更新 ing~ 所有文章、图解和代码全部是金刀亲手完成。内容全部放在了[github](https://github.com/glodknife "github")和[gitee](https://gitee.com/goldknife6 "gitee")方便小伙伴们阅读和调试，另外还有更多小惊喜等你发现~
>
> 如果你喜欢本篇文章，PLZ 一键三连（关注、点赞、在看）。
